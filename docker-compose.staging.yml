# Staging-specific Docker Compose overrides
#
# This file provides environment-specific overrides for staging deployments.
# It disables the local PostgreSQL container (uses managed DB) and configures
# ports dynamically based on the STAGING_SLOT variable.
#
# Usage:
#   STAGING_SLOT=1 docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-1 up -d
#
# Port Mapping (based on STAGING_SLOT):
#   - Campaign UI: 5000 + STAGING_SLOT (e.g., slot 1 = 5001)
#   - Airflow UI:  8080 + STAGING_SLOT (e.g., slot 1 = 8081)
#   - Frontend:    5173 + STAGING_SLOT (e.g., slot 1 = 5174)

services:
  # Disable local PostgreSQL - staging uses DigitalOcean Managed PostgreSQL
  # Note: We can't use profiles because dependent services still require it
  # Instead, we override the postgres service to be a lightweight noop
  postgres:
    image: alpine:latest
    container_name: staging-${STAGING_SLOT:-1}-postgres
    # Override env_file to avoid looking for .env.staging
    env_file: []
    # Override volumes to avoid mounting init scripts
    volumes: []
    command: ["sh", "-c", "echo 'PostgreSQL disabled - using managed database' && sleep infinity"]
    # No host port binding for staging Postgres; avoids conflicts with production noop port
    ports: []
    healthcheck:
      test: ["CMD", "true"]
      interval: 5s
      timeout: 3s
      retries: 1

  airflow-webserver:
    container_name: staging-${STAGING_SLOT:-1}-airflow-webserver
    depends_on:
      postgres:
        condition: service_healthy
      airflow-init:
        condition: service_started
    # Override env_file to avoid looking for .env.staging
    env_file: []
    environment:
      # Override database connection for managed PostgreSQL
      AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=require
      # Base URL so Airflow serves correctly under /airflow/ (see run-behind-proxy docs)
      AIRFLOW__WEBSERVER__BASE_URL: https://staging-${STAGING_SLOT:-1}.justapply.net/airflow
      # Override internal Postgres connection for services
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      # Add services to PYTHONPATH
      PYTHONPATH: /opt/airflow/services
      # Staging slot identifier for version tracking
      STAGING_SLOT: ${STAGING_SLOT:-1}
      DEPLOYED_SHA: ${DEPLOYED_SHA:-unknown}
      DEPLOYED_BRANCH: ${DEPLOYED_BRANCH:-unknown}
      DEPLOYED_AT: ${DEPLOYED_AT:-unknown}
    ports:
      - "${AIRFLOW_WEBSERVER_PORT:-8081}:8080"
    labels:
      - "staging.slot=${STAGING_SLOT:-1}"
      - "staging.service=airflow-webserver"

  airflow-scheduler:
    container_name: staging-${STAGING_SLOT:-1}-airflow-scheduler
    depends_on:
      airflow-init:
        condition: service_started
    # Override env_file to avoid looking for .env.staging
    env_file: []
    environment:
      AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=require
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      # Add services to PYTHONPATH
      PYTHONPATH: /opt/airflow/services
      STAGING_SLOT: ${STAGING_SLOT:-1}
      DEPLOYED_SHA: ${DEPLOYED_SHA:-unknown}
      DEPLOYED_BRANCH: ${DEPLOYED_BRANCH:-unknown}
    labels:
      - "staging.slot=${STAGING_SLOT:-1}"
      - "staging.service=airflow-scheduler"

  airflow-init:
    container_name: staging-${STAGING_SLOT:-1}-airflow-init
    depends_on: []
    # Override env_file to avoid looking for .env.staging
    env_file: []
    environment:
      AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=require
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      # Add services to PYTHONPATH
      PYTHONPATH: /opt/airflow/services
    labels:
      - "staging.slot=${STAGING_SLOT:-1}"
      - "staging.service=airflow-init"

  backend-api:
    container_name: staging-${STAGING_SLOT:-1}-backend-api
    depends_on: []
    # Override env_file to avoid looking for .env.staging
    env_file: []
    # Use image as built (no host mounts)
    # We must explicitly list the volumes we WANT, and hope it doesn't merge? 
    # Actually, to clear volumes, we can't easily do it in compose.
    # So we'll just mount the dist folder from the host if it existed, 
    # but it doesn't.
    # Better: move the frontend dist to a different location in the Dockerfile
    # that is NOT under /app.
    volumes:
      - /home/deploy/staging-${STAGING_SLOT:-1}/job-search-project/services:/app/services
      - /home/deploy/staging-${STAGING_SLOT:-1}/job-search-project/backend:/app
    environment:
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_SSL_MODE: require
      FLASK_ENV: production
      FLASK_DEBUG: 0
      ENVIRONMENT: ${ENVIRONMENT:-staging}
      # Airflow API: backend must reach airflow-webserver to trigger DAGs (same Docker network)
      # Set AIRFLOW_API_* in .env.staging-N; password for slot N is typically staging{N}admin
      AIRFLOW_API_URL: ${AIRFLOW_API_URL:-http://staging-${STAGING_SLOT:-1}-airflow-webserver:8080/api/v1}
      AIRFLOW_API_USERNAME: ${AIRFLOW_API_USERNAME:-admin}
      AIRFLOW_API_PASSWORD: ${AIRFLOW_API_PASSWORD:-admin}
      # Version tracking
      STAGING_SLOT: ${STAGING_SLOT:-1}
      DEPLOYED_SHA: ${DEPLOYED_SHA:-unknown}
      DEPLOYED_BRANCH: ${DEPLOYED_BRANCH:-unknown}
      DEPLOYED_AT: ${DEPLOYED_AT:-unknown}
    ports:
      - "${CAMPAIGN_UI_PORT:-5001}:5000"
    labels:
      - "staging.slot=${STAGING_SLOT:-1}"
      - "staging.service=backend-api"

  frontend:
    container_name: staging-${STAGING_SLOT:-1}-frontend
    # Override env_file to avoid looking for .env.staging
    env_file: []
    ports:
      - "${FRONTEND_PORT:-5174}:80"
    labels:
      - "staging.slot=${STAGING_SLOT:-1}"
      - "staging.service=frontend"

networks:
  job_search_network:
    name: staging_${STAGING_SLOT:-1}_network

volumes:
  postgres_data:
    name: staging_${STAGING_SLOT:-1}_postgres_data
