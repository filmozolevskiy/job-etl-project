name: Deploy

on:
  push:
    branches:
      - main
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    name: Deploy to Production (Staging-10)
    runs-on: ubuntu-latest
    environment: production
    # Only deploy if CI workflow succeeded OR manually triggered OR pushed to main
    if: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper git operations
          ref: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch) || github.ref }}

      - name: Verify CI passed (for manual triggers)
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch: context.ref.replace('refs/heads/', ''),
              per_page: 5
            });
            
            // Find the latest CI run for this branch
            const ciRun = runs.workflow_runs[0];
            
            if (!ciRun) {
              console.log('WARNING: No CI run found. Proceeding with deployment...');
              return;
            }
            
            if (ciRun.status !== 'completed') {
              console.log(`WARNING: CI workflow is still ${ciRun.status}. Proceeding anyway...`);
              return;
            }
            
            if (ciRun.conclusion !== 'success') {
              console.log(`WARNING: CI workflow ${ciRun.conclusion}. Proceeding anyway...`);
              return;
            }
            
            console.log(`SUCCESS: CI workflow passed (run #${ciRun.run_number})`);

      - name: Verify droplet status via DigitalOcean API
        id: droplet
        env:
          DO_API_TOKEN: ${{ secrets.DIGITALOCEAN_API_TOKEN }}
          DROPLET_IP: ${{ secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          set -euo pipefail
          echo "=== Verifying droplet status via DigitalOcean API ==="
          if [ -z "${DO_API_TOKEN}" ]; then
            echo "WARNING: DIGITALOCEAN_API_TOKEN not set. Skipping API verification."
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! command -v jq &> /dev/null; then
            echo "WARNING: jq not available. Installing..."
            sudo apt-get update && sudo apt-get install -y jq
          fi
          DROPLETS=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${DO_API_TOKEN}" \
            "https://api.digitalocean.com/v2/droplets")
          if ! echo "$DROPLETS" | jq -e '.droplets' > /dev/null 2>&1; then
            echo "WARNING: Could not fetch droplets from API. Using provided IP: ${DROPLET_IP}"
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi
          DROPLET=$(echo "$DROPLETS" | jq -r --arg ip "${DROPLET_IP}" '.droplets[] | select(.networks.v4[]?.ip_address == $ip)')
          if [ -z "$DROPLET" ] || [ "$DROPLET" = "null" ]; then
            echo "WARNING: Droplet with IP ${DROPLET_IP} not found. Using provided IP."
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
          else
            DROPLET_ID=$(echo "$DROPLET" | jq -r '.id')
            DROPLET_NAME=$(echo "$DROPLET" | jq -r '.name')
            DROPLET_STATUS=$(echo "$DROPLET" | jq -r '.status')
            DROPLET_IP_FOUND=$(echo "$DROPLET" | jq -r '.networks.v4[] | select(.type == "public") | .ip_address' | head -1)
            echo "Found droplet: ${DROPLET_NAME} (ID: ${DROPLET_ID})"
            echo "Status: ${DROPLET_STATUS}"
            echo "IP: ${DROPLET_IP_FOUND}"
            echo "id=${DROPLET_ID}" >> $GITHUB_OUTPUT
            echo "ip=${DROPLET_IP_FOUND}" >> $GITHUB_OUTPUT
            echo "status=${DROPLET_STATUS}" >> $GITHUB_OUTPUT
            echo "name=${DROPLET_NAME}" >> $GITHUB_OUTPUT
          fi

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Configure Git and SSH
        env:
          DROPLET_IP: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          git config --global url."git@github.com:".insteadOf "https://github.com/"
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null || true
          ssh-keyscan -H ${DROPLET_IP} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get repository URL
        id: repo
        run: |
          REPO_URL=$(git remote get-url origin)
          if [[ "$REPO_URL" == https://* ]]; then
            REPO_URL=$(echo "$REPO_URL" | sed 's|https://github.com/|git@github.com:|')
          fi
          echo "url=$REPO_URL" >> $GITHUB_OUTPUT

      - name: Deploy to production (staging-10)
        env:
          DROPLET_USER: deploy
          DROPLET_HOST: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
          REPO_URL: ${{ steps.repo.outputs.url }}
        run: |
          set -euo pipefail
          
          SLOT=10
          BRANCH=main
          REPO_URL="${{ steps.repo.outputs.url }}"
          
          echo "=== Deploying to staging-${SLOT} ==="
          
          # Use non-quoted heredoc to allow local variable expansion
          # This is simpler and less error-prone for passing many variables
          ssh -o StrictHostKeyChecking=accept-new "${DROPLET_USER}@${DROPLET_HOST}" bash << DEPLOY_EOF
            set -euo pipefail
            
            SLOT=${SLOT}
            BRANCH=${BRANCH}
            REPO_URL=${REPO_URL}
            PROJECT_DIR="/home/deploy/staging-\$SLOT/job-search-project"
            ENV_FILE="/home/deploy/staging-\$SLOT/.env.staging-\$SLOT"
            
            echo "=== Preparing production slot directory ==="
            mkdir -p "/home/deploy/staging-\$SLOT"
            cd "/home/deploy/staging-\$SLOT"
            
            if [ -d "\$PROJECT_DIR" ]; then
              echo "Updating repository..."
              cd "\$PROJECT_DIR"
              git fetch origin
              git checkout "\$BRANCH"
              git reset --hard "origin/\$BRANCH"
              git clean -fd
            else
              echo "Cloning repository..."
              git clone "\$REPO_URL" job-search-project
              cd "\$PROJECT_DIR"
              git checkout "\$BRANCH"
            fi
            
            if [ ! -f "\$ENV_FILE" ]; then
              echo "ERROR: Environment file not found: \$ENV_FILE"
              exit 1
            fi
            
            # Export everything needed for compose
            export STAGING_SLOT=\$SLOT
            export CAMPAIGN_UI_PORT=$((5000 + SLOT))
            export AIRFLOW_WEBSERVER_PORT=$((8080 + SLOT))
            export FRONTEND_PORT=$((5173 + SLOT))
            export POSTGRES_NOOP_PORT=$((54320 + SLOT))
            export ENVIRONMENT=staging
            
            # Load env file but immediately re-export STAGING_SLOT to ensure it's correct
            set -a
            source "\$ENV_FILE"
            set +a
            export STAGING_SLOT=\$SLOT
            
            # Link env files for compose
            ln -sf "\$ENV_FILE" .env
            ln -sf "\$ENV_FILE" .env.staging
            
            echo "=== Building and starting containers ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-\$SLOT" build
            
            # Run migrations
            cp -f dbt/profiles.staging.yml dbt/profiles.yml
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-\$SLOT" run --rm --no-deps airflow-webserver \
              bash -c 'cd /opt/airflow/dbt && dbt run --project-dir . --target-path /tmp/dbt_target --log-path /tmp/dbt_logs'
            
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-\$SLOT" up -d
            
            echo "=== Deployment to slot \$SLOT complete ==="
          DEPLOY_EOF

      - name: Verify deployment
        env:
          DROPLET_USER: deploy
          DROPLET_HOST: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          set -e
          echo "Waiting for services to be ready..."
          sleep 30
          
          # Health check via SSH
          echo "Checking health via SSH (localhost:5010 on droplet)..."
          for i in {1..12}; do
            if ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 "${DROPLET_USER}@${DROPLET_HOST}" \
              'curl -sf http://localhost:5010/api/health > /dev/null'; then
              echo "SUCCESS: Health check passed"
              exit 0
            fi
            echo "Attempt $i/12: Health check failed, retrying in 10s..."
            sleep 10
          done
          
          echo "ERROR: Health check failed after 12 attempts"
          ssh "${DROPLET_USER}@${DROPLET_HOST}" "docker ps -a | grep staging" || true
          exit 1
