name: Deploy to Production

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    name: Deploy to Production (Staging-10)
    runs-on: ubuntu-latest
    # Only deploy if CI workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper git operations
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Verify CI passed (for manual triggers)
        if: github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch: context.ref.replace('refs/heads/', ''),
              per_page: 5
            });
            
            // Find the latest CI run for this branch
            const ciRun = runs.workflow_runs[0];
            
            if (!ciRun) {
              console.log('⚠️ No CI run found. Proceeding with deployment...');
              return;
            }
            
            if (ciRun.status !== 'completed') {
              throw new Error(`CI workflow is still ${ciRun.status}. Wait for it to complete.`);
            }
            
            if (ciRun.conclusion !== 'success') {
              throw new Error(`CI workflow ${ciRun.conclusion}. Cannot deploy to production.`);
            }
            
            console.log(`✅ CI workflow passed (run #${ciRun.run_number})`);

      - name: Verify droplet status via DigitalOcean API
        id: droplet
        env:
          DO_API_TOKEN: ${{ secrets.DIGITALOCEAN_API_TOKEN }}
          DROPLET_IP: ${{ secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          set -euo pipefail
          
          echo "=== Verifying droplet status via DigitalOcean API ==="
          
          # Check if API token is provided
          if [ -z "${DO_API_TOKEN}" ]; then
            echo "⚠️ DIGITALOCEAN_API_TOKEN not set. Skipping API verification."
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if jq is available
          if ! command -v jq &> /dev/null; then
            echo "⚠️ jq not available. Installing..."
            sudo apt-get update && sudo apt-get install -y jq
          fi
          
          # List droplets and find the one matching our IP
          DROPLETS=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${DO_API_TOKEN}" \
            "https://api.digitalocean.com/v2/droplets")
          
          # Check if API call was successful
          if ! echo "$DROPLETS" | jq -e '.droplets' > /dev/null 2>&1; then
            echo "⚠️ Could not fetch droplets from API. Using provided IP: ${DROPLET_IP}"
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Find droplet by IP address
          DROPLET=$(echo "$DROPLETS" | jq -r --arg ip "${DROPLET_IP}" '.droplets[] | select(.networks.v4[]?.ip_address == $ip)')
          
          if [ -z "$DROPLET" ] || [ "$DROPLET" = "null" ]; then
            echo "⚠️ Droplet with IP ${DROPLET_IP} not found. Using provided IP."
            echo "ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
          else
            DROPLET_ID=$(echo "$DROPLET" | jq -r '.id')
            DROPLET_NAME=$(echo "$DROPLET" | jq -r '.name')
            DROPLET_STATUS=$(echo "$DROPLET" | jq -r '.status')
            DROPLET_IP_FOUND=$(echo "$DROPLET" | jq -r '.networks.v4[] | select(.type == "public") | .ip_address' | head -1)
            
            echo "Found droplet: ${DROPLET_NAME} (ID: ${DROPLET_ID})"
            echo "Status: ${DROPLET_STATUS}"
            echo "IP: ${DROPLET_IP_FOUND}"
            
            if [ "${DROPLET_STATUS}" != "active" ]; then
              echo "⚠️ Droplet status is ${DROPLET_STATUS}, not 'active'. Proceeding anyway..."
            fi
            
            echo "id=${DROPLET_ID}" >> $GITHUB_OUTPUT
            echo "ip=${DROPLET_IP_FOUND}" >> $GITHUB_OUTPUT
            echo "status=${DROPLET_STATUS}" >> $GITHUB_OUTPUT
            echo "name=${DROPLET_NAME}" >> $GITHUB_OUTPUT
          fi

      - name: Validate SSH key format
        run: |
          echo "=== Validating SSH key format ==="
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "❌ SSH_PRIVATE_KEY secret is empty"
            exit 1
          fi
          
          # Check if key starts with proper header
          KEY_HEADER=$(echo "${{ secrets.SSH_PRIVATE_KEY }}" | head -n 1)
          if [[ ! "$KEY_HEADER" =~ ^-----BEGIN.*PRIVATE.*KEY-----$ ]]; then
            echo "❌ SSH key does not start with proper header"
            echo "Expected: -----BEGIN ... PRIVATE KEY-----"
            echo "Got: $KEY_HEADER"
            exit 1
          fi
          
          # Check if key ends with proper footer
          KEY_FOOTER=$(echo "${{ secrets.SSH_PRIVATE_KEY }}" | tail -n 1)
          if [[ ! "$KEY_FOOTER" =~ ^-----END.*PRIVATE.*KEY-----$ ]]; then
            echo "❌ SSH key does not end with proper footer"
            echo "Expected: -----END ... PRIVATE KEY-----"
            echo "Got: $KEY_FOOTER"
            exit 1
          fi
          
          echo "✅ SSH key format validation passed"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Configure Git and SSH
        env:
          DROPLET_IP: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          git config --global url."git@github.com:".insteadOf "https://github.com/"
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          # Pre-populate known_hosts; keyscan can exit 1 (timeout, etc.) — don't fail the step.
          # Deploy uses StrictHostKeyChecking=accept-new, so SSH still works if keyscan fails.
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null || true
          ssh-keyscan -H ${DROPLET_IP} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get repository URL
        id: repo
        run: |
          REPO_URL=$(git remote get-url origin)
          # Convert HTTPS to SSH format if needed
          if [[ "$REPO_URL" == https://* ]]; then
            REPO_URL=$(echo "$REPO_URL" | sed 's|https://github.com/|git@github.com:|')
          fi
          echo "url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "Repository URL: $REPO_URL"

      - name: Deploy to production (staging-10)
        env:
          DROPLET_USER: deploy
          DROPLET_HOST: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
          REPO_URL: ${{ steps.repo.outputs.url }}
          DO_API_TOKEN: ${{ secrets.DIGITALOCEAN_API_TOKEN }}
        run: |
          set -euo pipefail
          
          SLOT=10
          BRANCH=main
          BASE_DIR="/home/deploy"
          SLOT_DIR="${BASE_DIR}/staging-${SLOT}"
          PROJECT_DIR="${SLOT_DIR}/job-search-project"
          ENV_FILE="${SLOT_DIR}/.env.staging-${SLOT}"
          
          # Calculate ports
          CAMPAIGN_UI_PORT=$((5000 + SLOT))
          AIRFLOW_PORT=$((8080 + SLOT))
          FRONTEND_PORT=$((5173 + SLOT))
          
          # Get commit info
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          
          echo "=== Deploying to production (staging-${SLOT}) ==="
          echo "Branch: ${BRANCH}"
          echo "Commit: ${COMMIT_SHORT}"
          echo "Repository: ${REPO_URL}"
          
          # Deploy via SSH - use quoted heredoc to avoid local expansion issues
          # and pass needed env vars explicitly
          ssh -o StrictHostKeyChecking=accept-new "${DROPLET_USER}@${DROPLET_HOST}" \
            "DROPLET_HOST='${DROPLET_HOST}' REPO_URL='${REPO_URL}' bash" << 'DEPLOY_EOF'
            set -euo pipefail
            
            SLOT=10
            BRANCH=main
            BASE_DIR="/home/deploy"
            SLOT_DIR="${BASE_DIR}/staging-${SLOT}"
            PROJECT_DIR="${SLOT_DIR}/job-search-project"
            ENV_FILE="${SLOT_DIR}/.env.staging-${SLOT}"
            
            # Calculate ports
            CAMPAIGN_UI_PORT=$((5000 + SLOT))
            AIRFLOW_PORT=$((8080 + SLOT))
            FRONTEND_PORT=$((5173 + SLOT))
            
            COMMIT_SHA="${{ github.sha }}"
            COMMIT_SHORT="${COMMIT_SHA:0:7}"
            
            echo "=== Preparing production slot directory ==="
            mkdir -p "${SLOT_DIR}"
            cd "${SLOT_DIR}"
            
            # Clone or update repository (force clean deploy; discard local changes)
            if [ -d "${PROJECT_DIR}" ]; then
              echo "Updating existing repository..."
              cd "${PROJECT_DIR}"
              git fetch origin
              git checkout "${BRANCH}"
              git reset --hard "origin/${BRANCH}"
              git clean -fd
              mkdir -p airflow/plugins
            else
              echo "Cloning repository..."
              git clone "${REPO_URL}" job-search-project
              cd "${PROJECT_DIR}"
              git checkout "${BRANCH}"
              mkdir -p airflow/plugins
            fi
            
            # Verify we're on the correct commit
            CURRENT_SHA=$(git rev-parse HEAD)
            if [ "${CURRENT_SHA}" != "${COMMIT_SHA}" ]; then
              echo "Checking out commit ${COMMIT_SHORT}..."
              git checkout "${COMMIT_SHA}"
            fi
            
            # Verify environment file exists
            if [ ! -f "${ENV_FILE}" ]; then
              echo "ERROR: Environment file not found: ${ENV_FILE}"
              echo "Please create the environment file first."
              exit 1
            fi
            
            # Write deployment metadata
            echo "=== Writing deployment metadata ==="
            cat > "${SLOT_DIR}/version.json" << VERSIONEOF
            {
                "slot": ${SLOT},
                "branch": "${BRANCH}",
                "commit_sha": "${COMMIT_SHA}",
                "commit_short": "${COMMIT_SHORT}",
                "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "deployed_by": "github-actions",
                "workflow_run": "${{ github.run_id }}",
                "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
VERSIONEOF
            
            # Export environment variables for docker compose
            export STAGING_SLOT=${SLOT}
            export DEPLOYED_SHA="${COMMIT_SHA}"
            export DEPLOYED_BRANCH="${BRANCH}"
            export CAMPAIGN_UI_PORT=${CAMPAIGN_UI_PORT}
            export AIRFLOW_WEBSERVER_PORT=${AIRFLOW_PORT}
            export FRONTEND_PORT=${FRONTEND_PORT}
            export ENVIRONMENT=staging
            
            # Load environment file
            set -a
            source "${ENV_FILE}"
            set +a
            
            cd "${PROJECT_DIR}"
            
            # Compose uses env_file: .env.staging and .env (relative to project dir).
            # Symlink them to the slot env so Compose can load secrets.
            ln -sf "../.env.staging-${SLOT}" .env
            ln -sf "../.env.staging-${SLOT}" .env.staging
            echo "Linked .env and .env.staging -> ${ENV_FILE}"
            
            echo "=== Stopping existing containers ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" down --remove-orphans || true
            
            echo "=== Building containers ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" build
            
            echo "=== Running initial dbt (create marts including fact_jobs) ==="
            cp -f dbt/profiles.staging.yml dbt/profiles.yml
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" run --rm --no-deps airflow-webserver \
              bash -c 'cd /opt/airflow/dbt && dbt run --project-dir . --target-path /tmp/dbt_target --log-path /tmp/dbt_logs'
            
            echo "=== Starting containers ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" up -d
            
            echo "=== Waiting for services to start ==="
            sleep 30
            
            echo "=== Docker Compose status ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" ps -a
            
            echo ""
            echo "=== campaign-ui logs (last 60 lines) ==="
            docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" logs --tail=60 campaign-ui || true
            
            # Fail if no services are Up (including campaign-ui)
            if ! docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" ps -a | grep -q "Up"; then
              echo "ERROR: No containers are running. Deployment failed."
              docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-${SLOT}" logs --tail=100 || true
              exit 1
            fi
            
            echo ""
            echo "=== Production deployment complete ==="
            echo "Campaign UI: http://${DROPLET_HOST}:${CAMPAIGN_UI_PORT}"
            echo "Airflow UI:  http://${DROPLET_HOST}:${AIRFLOW_PORT}"
            echo "Commit: ${COMMIT_SHORT}"
            echo ""
DEPLOY_EOF
          
          echo "✅ Production deployment successful!"
          echo "Commit: ${COMMIT_SHORT}"
          echo "Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: Verify deployment
        env:
          DROPLET_USER: deploy
          DROPLET_HOST: ${{ steps.droplet.outputs.ip || secrets.DROPLET_HOST || '134.122.35.239' }}
        run: |
          set -e
          echo "Waiting for services to be ready..."
          sleep 30
          
          # Fail fast if no staging-10 containers (Deploy step may have failed or containers exited)
          PS_OUT=$(ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 "${DROPLET_USER}@${DROPLET_HOST}" \
            'cd /home/deploy/staging-10/job-search-project && docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-10 ps -a' 2>/dev/null || true)
          if ! echo "$PS_OUT" | grep -q "staging_10"; then
            echo "No staging-10 containers found. Deploy may have failed or containers exited."
            echo "=== All containers on droplet (docker ps -a) ==="
            ssh "${DROPLET_USER}@${DROPLET_HOST}" 'docker ps -a' || true
            echo ""
            echo "=== Docker Compose status (staging-10) ==="
            ssh "${DROPLET_USER}@${DROPLET_HOST}" 'cd /home/deploy/staging-10/job-search-project && docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-10 ps -a' || true
            echo ""
            echo "=== Recent container logs (campaign-ui, last 80 lines) ==="
            ssh "${DROPLET_USER}@${DROPLET_HOST}" 'cd /home/deploy/staging-10/job-search-project && docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-10 logs --tail=80 campaign-ui' || true
            exit 1
          fi
          
          # Health check via SSH (curl localhost on droplet) to avoid external firewall issues
          echo "Checking health via SSH (localhost:5010 on droplet)..."
          for i in {1..12}; do
            if ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 "${DROPLET_USER}@${DROPLET_HOST}" \
              'curl -sf http://localhost:5010/api/health > /dev/null'; then
              echo "✅ Health check passed"
              ssh "${DROPLET_USER}@${DROPLET_HOST}" 'curl -s http://localhost:5010/api/health' | jq '.' 2>/dev/null || true
              exit 0
            fi
            echo "Attempt $i/12: Health check failed, retrying in 10s..."
            sleep 10
          done
          
          echo "⚠️ Health check failed after 12 attempts"
          echo ""
          echo "=== All containers on droplet (docker ps -a) ==="
          ssh "${DROPLET_USER}@${DROPLET_HOST}" 'docker ps -a' || true
          echo ""
          echo "=== Docker Compose status (staging-10) ==="
          ssh "${DROPLET_USER}@${DROPLET_HOST}" 'cd /home/deploy/staging-10/job-search-project && docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-10 ps -a' || true
          echo ""
          echo "=== Recent container logs (campaign-ui, last 80 lines) ==="
          ssh "${DROPLET_USER}@${DROPLET_HOST}" 'cd /home/deploy/staging-10/job-search-project && docker compose -f docker-compose.yml -f docker-compose.staging.yml -p staging-10 logs --tail=80 campaign-ui' || true
          exit 1
