{{ config(
    materialized='incremental',
    unique_key=['jsearch_job_id', 'campaign_id'],
    on_schema_change='append_new_columns',
    schema='marts'
) }}

-- Marts layer: Fact Jobs
-- One row per unique job per campaign (deduplicated by jsearch_job_id, campaign_id)
-- Built from staging.jsearch_job_postings
-- Joined to dim_companies on employer_name (used for matching only, not stored)
-- Joined to staging.chatgpt_enrichments to get ChatGPT-enriched fields (prioritized via COALESCE)
-- Primary key: (jsearch_job_id, campaign_id) - composite key
-- Foreign keys: company_key, campaign_id (references job_campaigns)

with staging_jobs as (
    select
        jsearch_job_postings_key,
        jsearch_job_id,
        campaign_id,
        job_title,
        employer_name,
        job_location,
        job_employment_type,
        job_employment_types,
        employment_types,
        apply_options,
        job_apply_link,
        job_google_link,
        job_publisher,
        job_posted_at_datetime_utc,
        -- Enriched columns (populated by Enricher service)
        extracted_skills,
        seniority_level,
        remote_work_type,
        job_min_salary,
        job_max_salary,
        job_salary_period,
        job_salary_currency,
        dwh_load_date,
        dwh_load_timestamp,
        dwh_source_system
    from {{ ref('jsearch_job_postings') }}
    where jsearch_job_id is not null
        and campaign_id is not null
        -- Note: Removed campaign_id filter - fact_jobs should always contain all campaigns
        -- Staging layer handles campaign_id filtering for efficiency
),

-- Join to companies dimension
jobs_with_companies as (
    select
        sj.*,
        dc.company_key
    from staging_jobs sj
    left join {{ ref('dim_companies') }} dc
        on lower(trim(sj.employer_name)) = dc.normalized_company_name
),

-- Join to ChatGPT enrichments (separate table for priority logic)
jobs_with_chatgpt as (
    select
        jwc.*,
        ce.job_summary,
        ce.chatgpt_extracted_skills,
        ce.chatgpt_extracted_location,
        ce.chatgpt_seniority_level,
        ce.chatgpt_remote_work_type,
        ce.chatgpt_job_min_salary,
        ce.chatgpt_job_max_salary,
        ce.chatgpt_salary_period,
        ce.chatgpt_salary_currency,
        ce.chatgpt_enriched_at
    from jobs_with_companies jwc
    left join staging.chatgpt_enrichments ce
        on jwc.jsearch_job_postings_key = ce.jsearch_job_postings_key
),

-- Deduplicate on (jsearch_job_id, campaign_id), keeping the most recent record
with_derived as (
    select
        -- Natural keys (composite primary key)
        jsearch_job_id,
        campaign_id,
        
        -- Foreign key
        company_key,
        
        -- Essential job fields
        job_title,
        -- ChatGPT-specific fields (no rule-based equivalent)
        job_summary,  -- 2-sentence summary from ChatGPT (no rule-based equivalent)
        employer_name,
        -- Location: prioritize ChatGPT normalized location over API location
        COALESCE(chatgpt_extracted_location, job_location) as job_location,
        -- Employment type: consolidate fields (job_employment_type is string, employment_types is comma-separated from JSONB array)
        COALESCE(job_employment_type, employment_types) as employment_type,
        apply_options,
        job_apply_link,
        job_google_link,
        job_publisher,
        job_posted_at_datetime_utc,
        
        -- Enriched columns with COALESCE to prioritize ChatGPT over rule-based
        -- ChatGPT fields take priority, fallback to rule-based if ChatGPT not available
        COALESCE(chatgpt_extracted_skills, extracted_skills) as extracted_skills,
        COALESCE(chatgpt_seniority_level, seniority_level) as seniority_level,
        COALESCE(chatgpt_remote_work_type, remote_work_type) as remote_work_type,
        COALESCE(chatgpt_job_min_salary, job_min_salary) as job_min_salary,
        COALESCE(chatgpt_job_max_salary, job_max_salary) as job_max_salary,
        COALESCE(chatgpt_salary_period, job_salary_period) as job_salary_period,
        COALESCE(chatgpt_salary_currency, job_salary_currency) as job_salary_currency,
        
        chatgpt_enriched_at,  -- Timestamp when ChatGPT enrichment was completed
        
        -- Technical columns
        dwh_load_date,
        dwh_load_timestamp,
        dwh_source_system,
        
        -- Deduplication row number
        row_number() over (
            partition by jsearch_job_id, campaign_id
            order by dwh_load_timestamp desc
        ) as rn
        
    from jobs_with_chatgpt
)

select
    jsearch_job_id,
    campaign_id,
    company_key,
    job_title,
    job_summary,  -- 2-sentence summary generated by ChatGPT (only from ChatGPT, no rule-based fallback)
    employer_name,
    job_location,  -- COALESCE(chatgpt_extracted_location, job_location) - prioritized in with_derived
    employment_type,  -- Consolidated from job_employment_type, job_employment_types, employment_types
        apply_options,
        job_apply_link,
        job_google_link,
        job_publisher,
        job_posted_at_datetime_utc,
    -- Enriched columns (ChatGPT prioritized over rule-based via COALESCE)
    extracted_skills,  -- Skills: ChatGPT if available, else rule-based (JSON array)
    seniority_level,   -- Seniority: ChatGPT if available, else rule-based (intern, junior, mid, senior, executive)
    remote_work_type, -- Remote type: ChatGPT if available, else rule-based (remote, hybrid, onsite)
    job_min_salary,    -- Min salary: ChatGPT if available, else rule-based (yearly integer)
    job_max_salary,    -- Max salary: ChatGPT if available, else rule-based (yearly integer)
    job_salary_period, -- Salary period: ChatGPT if available, else rule-based (year, month, week, day, hour)
    job_salary_currency, -- Currency: ChatGPT if available, else rule-based (USD, CAD, EUR, GBP, or NULL)
    chatgpt_enriched_at,  -- Timestamp when ChatGPT enrichment was completed
    dwh_load_date,
    dwh_load_timestamp,
    dwh_source_system
from with_derived
where rn = 1
{% if is_incremental() %}
    -- Process new/updated records from staging
    -- Include records where either:
    -- 1. The job posting itself was updated (dwh_load_timestamp changed)
    -- 2. ChatGPT enrichment was added/updated (check if chatgpt_enriched_at is newer than max in fact_jobs)
    -- 3. If campaign_id filter was used in staging, process all records for that campaign (even old ones)
    and (
        dwh_load_timestamp > (select coalesce(max(dwh_load_timestamp), '1970-01-01'::timestamp) from {{ this }})
        or (
            chatgpt_enriched_at IS NOT NULL
            and chatgpt_enriched_at > (
                select coalesce(max(chatgpt_enriched_at), '1970-01-01'::timestamp)
                from {{ this }}
            )
        )
        {% if var('campaign_id', -1) != -1 %}
        -- If staging was filtered by campaign_id, reprocess all records for that campaign
        -- This ensures fact_jobs stays in sync when staging reprocesses a specific campaign
        or campaign_id = {{ var('campaign_id') }}
        {% endif %}
    )
{% endif %}
