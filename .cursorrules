# Project Rules & Standards

## 1. Core Principles (Global)
- **Explain as you code**: Briefly explain changes, non-trivial syntax, and design choices.
- **Teach**: Assume user is a junior engineer. Use clear, pragmatic examples.
- **linear standards**: All linear tasks should have a brief explanation of planed change, definition of done, QA strategy, edge cases coverage, unit/integration tests if relevant. 
- **Clarify**: If requirements are ambiguous, STOP and ask. Do not guess.
- **Plan**: Briefly explain each step before implementing.
- **Verify**: Always run lint/test/build before pushing to remote.
- **Limit Retries**: NEVER execute the exact same terminal command more than 3 times in a row. If a command produces very large output that you cannot parse in one go, use tools like `grep`, `tail`, `head`, or redirection to files instead of repeatedly running the command to "see more".
- **Docs**: Create/Update documentation in Linear issues, NOT in the repo (except strictly required config/PRD updates).
- **MCP Centrality**: Prioritize MCP services over other methods of communication (GitHub, DigitalOcean, Linear).

## 2. Workflow (Linear-Centric)
- **Linear Centrality**: All work starts/ends with Linear. Doc updates go to Linear issues, not codebase.
- **Isolation**: 1 Task = 1 Worktree (`.worktrees/linear-{id}-{desc}`) = 1 Branch = 1 Staging Slot.
- **No Direct Push**: `main` is protected. Use PRs via GitHub MCP.
- **Staging-First**: Fixes (CI/QA) must happen in the task's worktree/branch.
- **Status + Comment**: Whenever an agent changes an issue's status in Linear, they **must** add a comment on that issue (via **Linear MCP** `create_comment`) explaining the new status (e.g. "Moved to Code Review — PR #42 opened."). One status change = one comment; no status change without a comment..
- **PR ↔ Linear**: Every PR **must** include a link to the Linear issue in its description (e.g. "Linear: https://linear.app/…/issue/JOB-123" or "Closes JOB-123"). When creating a PR via **GitHub MCP**, set the PR body to include this link so the task is traceable.
- **Loop on CI/CD**: Must watch branch CI and iterate on failures until green. 1. Find the current branch and latest workflow run (GitHub MCP: PR `get_status` for head commit, or `python .github/scripts/query_ci_errors.py` for run by branch). 2. Poll until CI completes (re-check status; no `gh` CLI required). 3. If failed, inspect logs via `python .github/scripts/report_ci_errors.py <run_id>` or failed job details from GitHub MCP; implement a focused fix; commit and push. 4. Repeat until all required checks pass.

### Phase Checklist
#### 1. Development (Status: `Todo` -> `In Progress`)
- Read Linear issue via **Linear MCP**.
- Create worktree: `./scripts/create_worktree.sh <issue-id> <desc>`.
- Update Linear to `In Progress` via **Linear MCP** -> **Comment on Linear** (e.g. "Starting work; worktree created.") via **Linear MCP**.
- Implement changes in worktree.
- Run local tests/linting: `./scripts/pre-pr-check.sh`.
- Push branch -> **Wait & Check CI** (Mandatory): Use **GitHub MCP** to check status.
- Create PR via **GitHub MCP** (PR description **must** include a link to the Linear issue) -> Update Linear to `Code Review` via **Linear MCP** -> **Comment on Linear** (Dev Complete template: PR link, CI status) via **Linear MCP**.

#### 2. Code Review (Status: `Code Review`)
- Read linear issue description via **Linear MCP**.
- Read PR & comments via **GitHub MCP**.
- Review against [Code Quality Standards](#5-code-quality-standards) and requirements in liner issue.
- **Approved**: Update Linear to `QA` via **Linear MCP** -> **Comment on Linear** (e.g. "PR approved; ready for QA.") via **Linear MCP** -> Approve PR via **GitHub MCP**.
- **Changes Needed**: Update Linear to `Fixes needed` via **Linear MCP** -> **Comment on Linear** (brief summary of requested changes) via **Linear MCP** -> Request changes via **GitHub MCP**.

#### 3. QA (Status: `QA`)
- Claim Staging Slot (1-10) via Staging API or `marts.staging_slots` (or `./scripts/claim-staging-slot.sh <slot_id> [branch]` with `STAGING_ADMIN_JWT`; set `PURPOSE`/`PR_URL` for metadata).
- Deploy worktree/branch to slot: `./scripts/deploy-staging.sh <slot-id>`.
- **Verify**: After deploy, run `./scripts/verify-staging-ready.sh <slot-id>` from the repo. Confirm all containers started: on droplet `docker compose -f docker-compose.yml -f docker-compose.staging.yml -p "staging-<N>" ps`, or curl `http://127.0.0.1:<port>/api/health`, or `./scripts/check_staging_slots.sh`. Do not report "ready for QA" until verification passes.
- **Fail**: Update Linear to `Fixes needed` via **Linear MCP** -> **Comment on Linear** (QA failed: what was checked, what failed, slot used) via **Linear MCP**.
- **Pass**: Update Linear to `Ready to Deploy` via **Linear MCP** -> **Comment on Linear** (QA passed: what was verified, slot used) via **Linear MCP**.
- Must not proceed to next steps before user approval.

#### 4. Deploy (Status: `Ready to Deploy`)
- Verify PR approved + CI passing via **GitHub MCP**.
- Merge PR via **GitHub MCP**.
- **Wait & Check Post-Merge CI** (Mandatory): Use **GitHub MCP** to check status. Poll until the post-merge workflow run completes.
- **Do NOT move the Linear card to Done until post-merge CI/CD has passed.** If CI fails after merge, fix in a follow-up (or revert), then re-check CI; only when green proceed below.
- **When the task is completely done** (post-merge CI pass confirmed), perform in order:
  1. **Adjust Linear**: Update issue to `Done` via **Linear MCP** and add a comment (e.g. "Merged to main; post-merge CI passed; cleanup complete.").
  2. **Remove local worktree**: `./scripts/remove_worktree.sh <issue-id> <desc>`; delete remote branch via **GitHub MCP**.
  3. **Remove temporary files and logs**: Clean up any task-specific temp files, log files, or build artifacts (e.g. under worktree, `*.log`, `.pytest_cache`, `__pycache__`, or paths created during the task).
  4. **Release staging and tear down** (required): Run `./scripts/teardown-staging.sh <slot>` (releases slot via direct DB update on production droplet, then SSHs to staging droplet and runs `docker compose -p staging-<N> down`). No JWT required.

## 3. Tooling Registry
**Golden Rule**: Do NOT create new scripts without first checking this registry and the `scripts/` folder.
- If a script exists but lacks a feature, **enhance it**.
- Only create a new script if the functionality is completely distinct.

### Official Scripts
- **Worktree Management**:
  - Create: `./scripts/create_worktree.sh <issue-id> <desc>` (name: `.worktrees/linear-<id>-<desc>`, description normalized)
  - Remove: `./scripts/remove_worktree.sh <issue-id> <desc>`
  - List: `./scripts/list_worktrees.sh`
- **Pre-PR (local)**:
  - Lint + tests: `./scripts/pre-pr-check.sh` (ruff check, ruff format --check, pytest; run before opening a PR)
- **Deployment**:
  - Staging: `./scripts/deploy-staging.sh <slot-id> [branch]` (fails if backend health check does not return 200; optional env: `ISSUE_ID`, `PURPOSE` for slot metadata). After deploy: `./scripts/verify-staging-ready.sh <slot>`.
  - Staging claim (API): `./scripts/claim-staging-slot.sh <slot_id> [branch]` (set `STAGING_ADMIN_JWT`; set `PURPOSE` or `PR_URL` and optionally `ISSUE_ID` for full metadata)
  - Staging teardown: `./scripts/teardown-staging.sh <slot> [slot ...]` (release via direct DB update on production droplet + `docker compose -p staging-<N> down` on staging droplet; no JWT required)
  - Production: `./scripts/deploy-production.sh` (Dedicated droplet)
  - Production verify: `./scripts/verify-production-health.sh [base_url]`
  - Docker credential helper (one-time on droplet): `./scripts/configure-docker-credential-helper.sh` (avoids unencrypted credentials warning)
  - Rollback Production: `./scripts/rollback-production.sh`
- **Database**:
  - Init Staging: `./scripts/init_staging_db.py <slot_id>` (Scans docker/init/*.sql)
  - Check Status: `./scripts/check_db_schema.sh`
- **Airflow**:
  - Pause/Unpause: `./scripts/airflow_pause.sh <slot_id> <dag_id> [pause|unpause]`
- **CI/CD Tools**:
  - Report Errors: `python .github/scripts/report_ci_errors.py`
  - Query Status: `python .github/scripts/query_ci_errors.py`

### Related scripts (distinct purpose — do not remove)
- **Staging provision (on droplet)**: `provision_staging_slot.sh <slot_id> [branch]`, `provision_all_staging_slots.sh [branch]` — create slot dir, clone, .env. Use before first deploy. `deploy-staging.sh` assumes slot already provisioned.
- **Staging restart (on droplet only)**: `restart_staging_slot.sh <slot_id>` — start containers for one slot when already on the droplet. `deploy-staging.sh` does full deploy from local (SSH, fetch, build, up).
- **Staging status overview**: `check_staging_slots.sh` — list all slots (NOT SET UP / RUNNING / etc.) from droplet paths. Use for quick overview; for "ready for QA?" use `verify-staging-ready.sh <slot>` (health HTTP check).
- **Production**: `deploy-production.sh` deploys the **dedicated production** droplet.
- **Diagnostics**: `diagnose-production.sh` runs production health checks.

## 4. Architecture Patterns
### Tech Stack
- **Frontend**: React (TypeScript).
- **Backend**: Python 3.11+ (Flask/FastAPI).
- **Database**: PostgreSQL (Medallion schema).
- **Transformation**: dbt.
- **Orchestration**: Apache Airflow.
- **Infrastructure**: Docker, DigitalOcean.

### Medallion Architecture
- **Raw (Bronze)**: `raw` schema. Near-original JSON from APIs. Created by Extractors.
- **Staging (Silver)**: `staging` schema. Cleaned, typed, normalized. Technical cols added.
- **Marts (Gold)**: `marts` schema. Business logic, Facts, Dimensions. Ready for consumption.

### Service Boundaries
- **Extractors**: Python. API -> `raw` table. No transformations.
- **Enrichers**: Python. `raw`/`staging` -> `staging` (add fields).
- **Rankers**: Python. `marts` -> `marts.dim_ranking`. Deterministic scoring.
- **Orchestration**: Airflow. Controls flow. No business logic in DAGs.

### Data Flow Principles
- **Direction**: External API -> Raw -> Staging -> Marts -> UI/Notify.
- **Infrastructure**: Tables init via Docker SQL scripts.
- **Consumption**: UI reads only from `marts` or specific app DBs.

## 5. Code Quality Standards
### Python
- **Style**: PEP 8, max 100 chars, `ruff` compliant.
- **Naming**: `snake_case` (modules/funcs), `PascalCase` (classes), `UPPER_SNAKE` (constants).
- **Types**: Required for ALL public functions/methods.
- **Docstrings**: Google-style required for public entities & complex logic.
- **No Magic**: Avoid hardcoded secrets (use env vars).

### Remove AI code slop
- Extra comments that are unnecessary or inconsistent with local style
- Defensive checks or try/catch blocks that are abnormal for trusted code paths
- Casts to `any` used only to bypass type issues
- Deeply nested code that should be simplified with early returns
- Other patterns inconsistent with the file and surrounding codebase
- Keep behavior unchanged unless fixing a clear bug.
- Prefer minimal, focused edits over broad rewrites.
- Keep the final summary concise (1-3 sentences).

### Design & Patterns
- **Loosely Coupled**: Depend on interfaces/signatures, not concrete implementations. Use Dependency Injection.
- **High Cohesion**: Single Responsibility Principle. One module/function = one job.
- **DRY**: Extract common logic, but prefer duplication over incorrect abstraction.
- **Simplicity**: YAGNI. Don't over-engineer.

### SQL & dbt
- **Naming**: 
  - Raw/Staging: `<source>_<entity>` (e.g., `jsearch_jobs`).
  - Marts: `fact_<name>`, `dim_<name>`.
- **Style**: Lowercase keywords, 1 column per line in SELECT.
- **Structure**: Use CTEs for logic steps.
- **Tests**: `unique` + `not_null` on PKs required.

### Testing
- **Unit**: `pytest` for logic/transformation rules.
- **Integration**: End-to-end flows (Extractor -> Raw -> Marts).
- **Validation**: Run `ruff` and `dbt test` before pushing.

### General
- **Clean Code**: No unused imports/vars. No `print` (use logging).
- **Human-Like**: No "Generated by AI" comments.
- **Atomic Commits**: One logical change per commit.

## 6. Master Enforcement (CRITICAL)
- **NEVER** implement changes in the root directory.
- **ALWAYS** run `./scripts/create_worktree.sh` before writing any code.
- **ALWAYS** follow the [Phase Checklist](#phase-checklist) step-by-step.
- **NEVER** move a Linear issue to `Done` until post-merge CI/CD has passed successfully.
- If an agent fails to use a worktree, the user will reject the work.
